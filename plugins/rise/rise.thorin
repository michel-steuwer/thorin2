/// # The rise Plugin {#rise}

.plugin core;

/// @see thorin::rise
///
/// [TOC]
///
/// A minimal rise plugin
///
/// ## Operations
///
/// ### %rise.const
///

/// # Core rise

.ax %rise.toMem: Π.[T: *] -> T -> T;

.ax %rise.generate: Π.[n: .Nat].[T: *] -> (.Idx n -> T) -> «n; T»;
.ax %rise.idx: Π.[n: .Nat].[T: *] -> .Idx n -> «n; T» -> T;

.ax %rise.take  : Π [n: .Nat].[m: .Nat].[T: *] -> «%core.nat.add(n, m); T» -> «n; T»;
.ax %rise.drop  : Π [n: .Nat].[m: .Nat].[T: *] -> «%core.nat.add(n, m); T» -> «m; T»;
.ax %rise.concat: Π.[n: .Nat].[m: .Nat].[T: *] -> «n; T» -> «m; T» -> «%core.nat.add(n, m); T»;

.ax %rise.split: Π [n: .Nat].[m: .Nat].[T: *] -> «%core.nat.mul(m, n); T» -> «m; «n; T»»;
.ax %rise.join : Π.[n: .Nat].[m: .Nat].[T: *] -> «m; «n; T»» -> «%core.nat.mul (m, n); T»;

.ax %rise.slide: Π.[n: .Nat][sz: .Nat][sp: .Nat].[T: *] ->
                   «%core.nat.mul(sp, %core.nat.add(n, sz)); T» -> «%core.nat.add(1, n); «sz; T»»;
.ax %rise.circularBuffer: Π [alloc: .Nat][sz: .Nat].[n: .Nat].[S: *].[T: *] ->
                            (S -> T) -> «%core.nat.add(n, sz); S» -> «%core.nat.add(n, 1); «sz; T»»;
.ax %rise.rotateValues: Π [sz: .Nat].[n: .Nat].[T: *] ->
                          (T -> T) -> «%core.nat.add(n, sz); T» -> «%core.nat.add(n, 1); «sz; T»»;

.ax %rise.transpose: Π.[n: .Nat].[m: .Nat].[T: *] -> «n; «m; T»» -> «m; «n; T»»;

.ax %rise.gather : Π.[n: .Nat].[m: .Nat].[T: *] -> «m; .Idx n» -> «n; T» -> «m; T»;
.ax %rise.scatter: Π.[n: .Nat].[m: .Nat].[T: *] -> «n; .Idx m» -> «n; T» -> «m; T»;
.ax %rise.reorder: Π [n: .Nat].[T: *] -> (.Nat -> .Nat) -> (.Nat -> .Nat) -> «n; T» -> «n; T»;

.ax %rise.padCst  : Π [l: .Nat][r: .Nat].[n: .Nat].[T: *] -> T -> «n; T» -> «%core.nat.add(l,%core.nat.add(n, r)); T»;
.ax %rise.padClamp: Π [l: .Nat][r: .Nat].[n: .Nat].[T: *] -> «n; T» -> «%core.nat.add(l,%core.nat.add(n, r)); T»;
.ax %rise.padEmpty: Π [p: .Nat].[n: .Nat].[T: *] -> «n; T» -> «%core.nat.add(n, p); T»;

.ax %rise.zip  : Π.[n: .Nat].[S: *].[T: *] -> «n; S» -> «n; T» -> «n; [S, T]»;
.ax %rise.unzip: Π.[n: .Nat].[S: *].[T: *] -> «n; [S, T]» -> [«n; S», «n; T»];

.ax %rise.Vec: [.Nat, *] -> *;
.ax %rise.vectorFromScalar: Π.[n: .Nat].[T: *] -> T -> %rise.Vec(n, T);
.ax %rise.asVector        : Π [n: .Nat].[m: .Nat].[T: *] -> «%core.nat.mul(m,n); T» -> «m; %rise.Vec(n, T)»;
.ax %rise.asVectorAligned : Π [n: .Nat].[m: .Nat].[T: *] -> «%core.nat.mul(m,n); T» -> «m; %rise.Vec(n, T)»;
.ax %rise.asScalar        : Π [n: .Nat].[m: .Nat].[T: *] -> «m; %rise.Vec(n, T)» -> «%core.nat.mul(m,n); T»;

.ax %rise.map      : Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.mapSeq   : Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.mapStream: Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;

.ax %rise.iterateStream: Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;

.ax %rise.mapFst: Π.[S1: *].[S2: *].[T: *] -> (S1 -> S2) -> [S1, T] -> [S2, T];
.ax %rise.mapSnd: Π.[S1: *].[S2: *].[T: *] -> (S1 -> S2) -> [T, S1] -> [T, S2];

.ax %rise.reduce:    Π.[n: .Nat]       .[T: *] -> (T -> T -> T) -> T -> «n; T» -> T;
.ax %rise.reduceSeq: Π.[n: .Nat].[S: *].[T: *] -> (T -> S -> T) -> T -> «n; S» -> T;

.ax %rise.scanSeq: Π.[n: .Nat].[S: *].[T: *] -> (T -> S -> T) -> T -> «n; S» -> «n; T»;

// not in core:
.ax %rise.nat(pow): «2; .Nat» -> .Nat;

.ax %rise.iterate: Π.[n: .Nat].[m: .Nat][k: .Nat].[T: *] ->
                     (Π [l: .Nat] -> «%core.nat.mul(l, n); T» -> «l; T») ->
                     «%core.nat.mul(m, %rise.nat.pow(n, k)); T» -> «m; T»;

.ax %rise.makeDepPair: Π.[fdt: .Nat -> *][n: .Nat] -> (fdt n) -> [m: .Nat, fdt m];
.ax %rise.dmatch: Π.[fdt: .Nat -> *].[T: *] -> [n: .Nat, fdt n] -> (Π [m: .Nat] -> (fdt m) -> T) -> T;

.ax %rise.DepArray: [n: .Nat, .Idx n -> *] -> *;

.ax %rise.depMapSeq: Π.[n: .Nat].[ft1: .Idx n -> *].[ft2: .Idx n -> *] ->
                       (Π [k: .Idx n] -> (ft1 k) -> (ft2 k)) ->
                       %rise.DepArray(n, ft1) -> %rise.DepArray(n, ft2);

.ax %rise.depZip: Π.[n: .Nat].[ft1: .Idx n -> *].[ft2: .Idx n -> *] ->
                        %rise.DepArray(n, ft1) ->
                        %rise.DepArray(n, ft2) ->
                        %rise.DepArray(n, .lm (i: .Idx n): * = [ft1 i, ft2 i]);

.lam %rise.sum(n: .Nat, f: .Idx n -> .Nat): .Nat =
    // generate 0 ... n-1
    .let numbers: «n; .Idx n» = %rise.generate (.lm (i: .Idx n): .Idx n = i);
    // apply f to all of them and then sum them up
    %rise.reduce (.lm a = .lm b = %core.nat.add(a, b)) 0 (%rise.map f numbers);

.ax %rise.depJoin: Π.[n: .Nat].[lenF: .Idx n -> .Nat].[T: *] ->
                        %rise.DepArray(n, .lm (i: .Idx n): * = «lenF i; T») ->
                        «%rise.sum(n, lenF); T»;

.ax %rise.partition: Π [m: .Nat][lenF: .Idx m -> .Nat].[n: .Nat].[T: *] ->
                        «n; T» ->
                        %rise.DepArray(m, .lm (i: .Idx m): * = «lenF i; T»);

/// # OpenMP Rise
.ax %rise.ompMapPar : Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.ompReducePar: Π.[n: .Nat].[T: *] -> (T -> T -> T) -> T -> «n; T» -> T;

/// # OpenCL Rise
.ax %rise.oclAddress: *;
.ax %rise.oclGlobal:  %rise.oclAddress;
.ax %rise.oclLocal:   %rise.oclAddress;
.ax %rise.oclPrivate: %rise.oclAddress;

.ax %rise.oclToMem: Π.[T: *][%rise.oclAddress] -> T -> T;
.ax %rise.oclReduceSeq: Π [%rise.oclAddress].[n: .Nat].[S: *].[T: *] -> (T -> S -> T) -> T -> «n; S» -> T;

.ax %rise.oclIterate: Π [%rise.oclAddress].[n: .Nat].[m: .Nat][k: .Nat].[T: *] ->
                        (Π [l: .Nat] -> «%core.nat.mul(l, n); T» -> «l; T») ->
                        «%core.nat.mul(m, %rise.nat.pow(n, k)); T» -> «m; T»;

.ax %rise.olcCircularBuffer: Π [%rise.oclAddress][alloc: .Nat][sz: .Nat].[n: .Nat].[S: *].[T: *] ->
                            (S -> T) -> «%core.nat.add(n, sz); S» -> «%core.nat.add(n, 1); «sz; T»»;
.ax %rise.olcRotateValues: Π [%rise.oclAddress][sz: .Nat].[n: .Nat].[T: *] ->
                          (T -> T) -> «%core.nat.add(n, sz); T» -> «%core.nat.add(n, 1); «sz; T»»;

.ax %rise.oclMapGlobal(x,y,z):    Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.oclMapLocal(x,y,z):     Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.oclMapWorkGroup(x,y,z): Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;

.ax %rise.oclRunPrimitive: Π [ls1: .Nat, ls2: .Nat, ls3: .Nat][gs1: .Nat, gs2: .Nat, gs3: .Nat].[T: *] -> T -> T;

/// # Cuda Rise
.ax %rise.cuMapBlock(x,y,z):    Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.cuMapGlobal(x,y,z):   Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.cuMapThread(x,y,z):   Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.cuMapWarp(x,y,z):     Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;
.ax %rise.cuMapLane(x,y,z):     Π.[n: .Nat].[S: *].[T: *] -> (S -> T) -> «n; S» -> «n; T»;

.ax %rise.cuFragmentType: *;
.ax %rise.cuFragment_ACC: %rise.cuFragmentType;
.ax %rise.cuFragment_A: %rise.cuFragmentType;
.ax %rise.cuFragment_B: %rise.cuFragmentType;

.ax %rise.cuMatrixLayout: *;
.ax %rise.cuMatrixLayout_ROW_MAJOR: %rise.cuMatrixLayout;

.ax %rise.cuFragment: Π [n: .Nat, m: .Nat, k: .Nat, T: *, f: %rise.cuFragmentType, l: %rise.cuMatrixLayout] -> *;

.ax %rise.asFragment: Π.[n: .Nat].[m: .Nat].[k: .Nat].[T: *].[f: %rise.cuFragmentType].[l: %rise.cuMatrixLayout] ->
                        «n; «m; T»» -> %rise.cuFragment(n, m, k, T, f, l);

.ax %rise.asMatrix: Π.[n: .Nat].[m: .Nat].[k: .Nat].[T: *] ->
                        %rise.cuFragment(n, m, k, T, %rise.cuFragment_ACC, %rise.cuMatrixLayout_ROW_MAJOR);

.ax %rise.generateFragment: Π.[n: .Nat].[m: .Nat].[k: .Nat].[T: *].[f: %rise.cuFragmentType] ->
                                T -> %rise.cuFragment(n, m, k, T, f, %rise.cuMatrixLayout_ROW_MAJOR);

.ax %rise.tensorMMA: Π.[la: %rise.cuMatrixLayout].[lb: %rise.cuMatrixLayout]
                      .[m: .Nat].[n: .Nat].[k: .Nat].[S: *].[T: *] ->
                        %rise.cuFragment(m, k, n, S, %rise.cuFragment_A, la) ->
                        %rise.cuFragment(k, n, m, S, %rise.cuFragment_B, lb) ->
                        %rise.cuFragment(m, n, k, T, %rise.cuFragment_ACC, %rise.cuMatrixLayout_ROW_MAJOR) ->
                        %rise.cuFragment(m, n, k, T, %rise.cuFragment_ACC, %rise.cuMatrixLayout_ROW_MAJOR);

.ax %rise.mapFragment: Π.[m: .Nat].[n: .Nat].[k: .Nat].[T: *].[f: %rise.cuFragmentType].[l: %rise.cuMatrixLayout] ->
                        (T -> T) -> %rise.cuFragment(n, m, k, T, f, l) -> %rise.cuFragment(n, m, k, T, f, l);

.ax %rise.globalToShared: Π.[T: *] -> T -> T;
